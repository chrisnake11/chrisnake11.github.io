---
title: 量子基编码和振幅编码
published: 2024-10-10T19:59:05Z
description: '量子基编码和振幅编码'
image: ''
tags: ['Quantum Computing']
category: 'Quantum Computing'
draft: false
---

# 量子基编码

基向量编码会把经典比特中的每个比特映射为单个量子比特基态$\ket{0}$,$\ket{1}$。。

对于长度为4bits的经典数据，如:[0101]，映射为量子比特后为:
$$
\ket{x} = \ket{0101}
$$

假设有一个数据$x = 3$，二进制为$11$，对应的量子编码为$\ket{11}$，需要两个量子比特。

对于数据$x = [3, 2]$，二进制为$[11, 10]$，对应的量子编码可能为$\ket{1110}$，需要4个量子比特。

$\ket{11}$基编码的**逻辑电路**:

$$
\ket{0} \rightarrow X \rightarrow \ket{1} \\
\ket{0} \rightarrow X \rightarrow \ket{1}
$$

基编码简单容易实现，只需要对$\ket{0}$使用NOT门就可以实现。但是需要的量子比特数量与经典比特数量相同。
> 每个量子比特相互独立，无法充分利用量子纠缠的特性。


# 振幅编码

使用量子基态的概率辐来表示经典数据的值。

数据的值需要归一化才能作为概率辐。

对于长度为4bits的经典数据，如:[0101]，对0，1，0，1归一化后，可以编码为量子态：
$$
\ket{x} = 0*\ket{00} + \frac{1}{\sqrt{2}}\ket{01} + 0*\ket{10} + \frac{1}{\sqrt{2}}\ket{11}
$$

振幅编码只需要$\log_2{n}$个量子比特来表示更多的经典数据。

数据以量子概率辐的形式来表示（经过了归一化）

**逻辑电路示例：**

假设存在数据$x = [3, 2]$使用基编码需要**4个量子比特**，如果把数组的entry看作振幅，经过归一化后可以使用**1个量子比特**进行编码。

$$
\sqrt{3^2 + 2^2} = \sqrt13 \\
\ket{x} = \frac{3}{\sqrt{13}} \ket{0} + \frac{2}{\sqrt13} \ket{1}
$$

## 振幅编码能够压缩数据的原因

1. 振幅作为复数，振幅本身可以存储更多的数据。

2. 振幅编码中存在量子叠加态，从而可以用更少的量子比特表示更多的数据。

同时基编码将经典数据直接映射到量子比特的基态，无法利用量子叠加的特性实现并行计算。


假设想要同时存储0和1两个信息，使用基编码需要2个量子比特
$$
\ket{\psi} = \ket{0} \otimes \ket{1} = \ket{01}
$$

但是使用振幅编码，只需要一个$\ket{\beta}$态即可
$$
\ket{\beta} = \frac{1}{\sqrt2}\ket{0} + \frac{1}{\sqrt2}\ket{1}
$$
这个量子可以以概率形式坍缩为$\ket{0}$或$\ket{1}$，处于二者的概率叠加态中。

量子信息的**存储**并不是直接存储$\ket{0}$或$\ket{1}$，而是**同时“包含”这两种状态信息，也就是说这个量子态同时具有处于两种量子态下的概率幅**。

振幅编码可以充分利用量子纠缠的特性，并且充分发挥**量子并行运算**的优点，对于单个量子比特，可以**同时操作2个经典比特的数据**，尽管在测量时量子态会坍缩为单一的状态，但是能够经过量子叠加同时**影响到多个计算路径**。
